
# Esercizio 1

## (a)

1. $nlog(n)+n^3=\Omega(n^2\sqrt{n})$ ? Si
2. $2^n=O(n^{100})$ ? No ($2^n=\omega(n^{100})\implies 2^n=\Omega(n^{100})$)
3. $loglog(n)=o(log(n))$ ? Si
4. $2^n=\Theta(2^{4n})$ ? No ($2^n=O(2^{4n}),2^n\neq\Omega(2^{4n})$)
5. $n^{2001}=\omega(n^2log(n))$ ? Si
6. $2^n=o(3^n)$ ? Si
7. $\frac{n^4+n+1}{\sqrt{n^3+3}}=o(n^{2.5})$ ? No ($\frac{n^4+n+1}{\sqrt{n^3+3}}=\Theta(n^{2.5})$)
8. $2^n=o(2^{n}+8)$ ? No ($2^n=\Theta(2^n+8)$)


# Esercizio 2

L'idea è quella di costruire un vettore ausiliario, partendo dall'originale, in tempo $O(n)$
Il vettore ausiliario sarè costruito in questo modo:
```python
b = [0]*n
b[0]=a[0]
for i in range(1,n):
    b[i] = b[i-1]+a[i]
```

In questo modo otterrò un vettore ordinato, dove posso andare ad eseguire una RIcercaBinaria, che in tempo $O(log(n))$ mi trova l'indice k richiesto dall'esercizio.


Il codice della creazione dell'oracolo è questo:
```python
def creaoracolo(a):
    n=len(a)
    if n==1:
        return 1
    b = [0]*n
    b[0]=a[0]

    for i in range(1,n):
        b[i] = b[i-1]+a[i]

    indice = InterrogaOracolo(b,2)
    return indice
```

Mentre la funzione InterrogaOracolo è questa:
```python
def InterrogaOracolo(a,k):# deve rispondere in tempo log n
    n=len(a)
    lx, rx = 0, n-1
    a[0] = k*a[0]
    sx,dx = 0,0
    cx = (lx + rx)//2
    # devo avere che la somma degli elementi a[1:k]>=a[k+1:n]
    while lx<=rx:
        sx = BinSearchLEQ(a,a[cx])
        dx = BinSearchGT(a,a[cx])
        if sx == dx:
            return cx+1
        elif sx>dx:
            cx-=1
            rx = cx
        else:
            cx+=1
            lx=cx
    return cx+1
```

Le funzioni ausiliarie che ho usato, ovvero BinSearchLEQ e BinSearchGT, sono funzioni che in tempo logaritmico mi trovano la somma dei valori compresi tra $A[1:m]$ e $A[m+1:n]$ ($m$ non è altro che il valore posto esattamente al centro dell'array, quello che nel codice è segnato come $cx=\frac{(rx+lx)}{2}$)

Il costo dell'algoritmo InterrogaOracolo dovrebbe essere $O(log(n))$ 